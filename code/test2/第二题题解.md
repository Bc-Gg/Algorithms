# 第二题题解

## 通俗的题目解读

#### 你有三个元素（0，1，2）排排坐，你需要排N个位置。每个元素的相邻元素不能相通，整个排序序列的头尾元素不能相同。

## 怎么想这个问题？

#### 1 . 维护一个带三叉树，在最后剪枝->去掉首尾相同的情况

#### （一开始这么做的，把时间干爆了，应该带备忘录

#### 2. 模拟排排坐的过程 -> 非常简单啊

#### （这次的题解

#### 3. 暴力枚举所有情况 -> 类似permutation但是......

#### （可以轻松达到O(n!)

## 题解

##### 假设我们需要求序列长度为n的序列的所有可能排列个数。因此我们可以在n次循环中维护一个数组 plate[9]，其初值我们可以以长度为2的序列为基准：

```
plate[9] = {0, 1, 1, 1, 0, 1, 1, 1, 0};
```

##### 其中下标的含义是

$$
head_i^j = \lfloor i \div 3 \rfloor \\
tail_i^j = i \text { mod } 3
$$



##### 如此我们可以发现，在第j次循环中，用plate^j_i代表的是以(i / 3)为首， 以 (i % 3) 为尾的序列在第j次循环结束之后所有可能的序列数，所以我们可以有如下迭代公式

$$
plate_i^{j} = \sum_{k=0}^2 plate^{j-1}_{head*3+k} - plate^{j-1}_{head*3+tail}
$$

##### 我们可以在一个每一次对j的循环中都用如上公式更新plate，并且在循环末尾进行剪枝，用首尾不应当有相同元素过滤掉所有不符合条件的序列数，把剩余的序列数求和相加即可求出答案。

##### 记住所有的plate数组中的数都应该是同步更新，所以我们应使用一个中间变量进行传递

##### 以下是关键代码

## 代码

```cpp
long long  ans[100] = {3,6};
long long st[9] ={0,1,1,1,0,1,1,1,0},sub[9];
void sum1(int n){ 												// 朴实无华的求和函数
    long long s = 0;
    for(int i = 0 ; i < 9 ; i++){
        if((i/3) != (i%3)) s+=st[i];
    }
    ans[n-1] = s;
}

int dp(int n){
    for(int i = 2 ; i <  n ; i++){ 					// 从 2 到 n 进行循环
        for(int j = 0 ; j < 9 ; j++){				// 对所有的plate进行循环
            int head = j / 3, tail = j % 3; // 求出头和尾
            sub[j] = 0;											// 用来传递的中间变量
          																	// 套用公式
            sub[j] = st[3*head] + st[3*head+1] + st[3*head+2] - st[3*head+tail];
        }
        for(int j = 0 ; j < 9 ; j++){				// 替换变量
            st[j] = sub[j];
        }
        sum1(i+1);													// 只对符合题目条件的数字进行求和
    }
}
```

## 改进的地方

#### 其实没必要开九个plate，开三个就行了

